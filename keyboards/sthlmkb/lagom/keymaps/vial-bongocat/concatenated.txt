

==================================================
File: vial.json
==================================================

{
   "name":"lagom",
   "vendorId":"0x8086",
   "productId":"0x5656",
   "lighting":"none",
   "matrix":{
      "rows":5,
      "cols":16
   },
   "layouts":{
      "labels":[
         "Split Backspace",
         "ISO Enter",
         "Split Left Shift",
         [
            "Bottom Row",
            "6.25u Space",
            "Split Space",
            "7u Space"
         ]
      ],
      "keymap":[
         [
            {
               "x":13.75
            },
            "1,15",
            {
               "x":0.25
            },
            "2,15",
            {
               "x":0.25
            },
            "0,0\n\n\n\n\n\n\n\n\ne",
            "0,1\n\n\n\n\n\n\n\n\ne"
         ],
         [
            {
               "y":0.25
            },
            "0,0",
            "0,1",
            "0,2",
            "0,3",
            "0,4",
            "0,5",
            "0,6",
            "0,7",
            "0,8",
            "0,9",
            "0,10",
            "0,11",
            "0,12",
            {
               "w":2
            },
            "0,14\n\n\n0,0",
            "0,15",
            {
               "x":0.25
            },
            "1,0\n\n\n\n\n\n\n\n\ne",
            "1,1\n\n\n\n\n\n\n\n\ne"
         ],
         [
            {
               "w":1.5
            },
            "1,0",
            "1,1",
            "1,2",
            "1,3",
            "1,4",
            "1,5",
            "1,6",
            "1,7",
            "1,8",
            "1,9",
            "1,10",
            "1,11",
            "1,12",
            {
               "w":1.5
            },
            "1,13\n\n\n1,0",
            "1,14"
         ],
         [
            {
               "w":1.75
            },
            "2,0",
            "2,1",
            "2,2",
            "2,3",
            "2,4",
            "2,5",
            "2,6",
            "2,7",
            "2,8",
            "2,9",
            "2,10",
            "2,11",
            {
               "w":2.25
            },
            "2,13\n\n\n1,0",
            "2,14"
         ],
         [
            {
               "w":2.25
            },
            "3,0\n\n\n2,0",
            "3,2",
            "3,3",
            "3,4",
            "3,5",
            "3,6",
            "3,7",
            "3,8",
            "3,9",
            "3,10",
            "3,11",
            {
               "w":1.75
            },
            "3,12",
            "3,13",
            "3,14"
         ],
         [
            {
               "w":1.25
            },
            "4,0\n\n\n3,0",
            {
               "w":1.25
            },
            "4,1\n\n\n3,0",
            {
               "w":1.25
            },
            "4,2\n\n\n3,0",
            {
               "w":6.25
            },
            "4,6\n\n\n3,0",
            {
               "w":1.25
            },
            "4,10\n\n\n3,0",
            {
               "w":1.25
            },
            "4,11\n\n\n3,0",
            {
               "x":0.5
            },
            "4,12",
            "4,13",
            "4,14"
         ],
         [
            {
               "y":0.5,
               "w":1.25
            },
            "4,0\n\n\n3,1",
            {
               "w":1.25
            },
            "4,1\n\n\n3,1",
            {
               "w":1.25
            },
            "4,2\n\n\n3,1",
            {
               "w":2.25
            },
            "4,4\n\n\n3,1",
            {
               "w":1.25
            },
            "4,6\n\n\n3,1",
            {
               "w":2.75
            },
            "4,8\n\n\n3,1",
            {
               "w":1.25
            },
            "4,10\n\n\n3,1",
            {
               "w":1.25
            },
            "4,11\n\n\n3,1"
         ],
         [
            {
               "y":-0.25,
               "x":15,
               "w":1.25,
               "h":2,
               "w2":1.5,
               "h2":1,
               "x2":-0.25
            },
            "2,13\n\n\n1,1"
         ],
         [
            {
               "y":-0.75,
               "w":1.5
            },
            "4,0\n\n\n3,2",
            "4,1\n\n\n3,2",
            {
               "w":1.5
            },
            "4,2\n\n\n3,2",
            {
               "w":7
            },
            "4,6\n\n\n3,2",
            {
               "w":1.5
            },
            "4,11\n\n\n3,2"
         ],
         [
            {
               "y":-0.25,
               "x":14
            },
            "2,12\n\n\n1,1"
         ],
         [
            {
               "w":1.25
            },
            "3,0\n\n\n2,1",
            "3,1\n\n\n2,1",
            {
               "x":9.75
            },
            "0,13\n\n\n0,1",
            "0,14\n\n\n0,1"
         ]
      ]
   }
}


==================================================
File: rules.mk
==================================================

VIA_ENABLE = yes
VIAL_ENABLE = yes
ENCODER_MAP_ENABLE = yes
VIAL_ENCODERS_ENABLE = yes
WPM_ENABLE = yes
LTO_ENABLE = yes
QMK_SETTINGS = no
OLED_ENABLE = yes
KEY_OVERRIDE_ENABLE = no
COMBO_ENABLE = no
TAP_DANCE_ENABLE = no


==================================================
File: concatenated.txt
==================================================



==================================================
File: typehud.h
==================================================

/* Copyright 2022 Chris Tanaka <https://github.com/christanaka>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include QMK_KEYBOARD_H

// clang-format off
#define _OLED_WIDTH         (OLED_DISPLAY_WIDTH - 1)
#define _OLED_HEIGHT        (OLED_DISPLAY_HEIGHT - 1)

#ifdef SPLIT_KEYBOARD
#define _PHYSICAL_PARTS 2
#else
#define _PHYSICAL_PARTS 1
#endif

#ifdef TYPEHUD_MATRIX_ROWS
#define _NML_MATRIX_ROWS TYPEHUD_MATRIX_ROWS
#else
#    ifdef SPLIT_KEYBOARD
#define _NML_MATRIX_ROWS (MATRIX_ROWS / 2)
#    else
#define _NML_MATRIX_ROWS MATRIX_ROWS
#    endif
#endif

#ifdef TYPEHUD_MATRIX_COLS
#define _NML_MATRIX_COLS TYPEHUD_MATRIX_COLS
#else
#define _NML_MATRIX_COLS (MATRIX_COLS * _PHYSICAL_PARTS)
#endif

#define _MATRIX_SIZE        2
#if defined(TYPEHUD_MATRIX_ROTATE_90) || defined(TYPEHUD_MATRIX_ROTATE_270)
#define _MATRIX_WIDTH       (_NML_MATRIX_ROWS * _MATRIX_SIZE + 2)
#define _MATRIX_HEIGHT      (_NML_MATRIX_COLS * _MATRIX_SIZE + 2)
#else
#define _MATRIX_WIDTH       (_NML_MATRIX_COLS * _MATRIX_SIZE + 2)
#define _MATRIX_HEIGHT      (_NML_MATRIX_ROWS * _MATRIX_SIZE + 2)
#endif
#define _MATRIX_X           0
#define _MATRIX_Y           (_OLED_HEIGHT - _MATRIX_HEIGHT + 1)
#define _MATRIX_RPAD        2
#define _MATRIX_PAD_WIDTH   (_MATRIX_WIDTH + _MATRIX_RPAD)

#define _BAR_WIDTH          3
#define _BAR_HEIGHT         _OLED_HEIGHT
#define _BAR_X              (_OLED_WIDTH - _BAR_WIDTH)

#define _AXIS_WIDTH         5
#define _AXIS_HEIGHT        _OLED_HEIGHT
#define _AXIS_TICK_WIDTH    3
#define _AXIS_SUBTICK_WIDTH 2
#define _AXIS_INTERVAL      3
#define _AXIS_TICK_INTERVAL 15
#define _AXIS_RPAD          2
#define _AXIS_PAD_WIDTH     (_AXIS_WIDTH + _AXIS_RPAD)
#define _AXIS_X             (_OLED_WIDTH - _BAR_WIDTH - _AXIS_PAD_WIDTH)

#define _CARET_WIDTH        3
#define _CARET_HEIGHT       5

#define _GRAPH_RPAD         2
#define _GRAPH_MAX_WIDTH    (_OLED_WIDTH - _BAR_WIDTH - _AXIS_PAD_WIDTH - _CARET_WIDTH - _GRAPH_RPAD - _MATRIX_PAD_WIDTH)
#define _GRAPH_WIDTH        (_GRAPH_MAX_WIDTH - 4)
#define _GRAPH_HEIGHT       31
#define _GRAPH_REFRESH      300
#define _GRAPH_X            (_MATRIX_WIDTH + _MATRIX_RPAD)
#define _GRAPH_Y            0
// clang-format on

static bool     is_initialized;
static uint16_t timer;
static int8_t   bar_height;
static uint8_t  wpm_arr[_GRAPH_WIDTH];
static uint8_t  point_arr[_GRAPH_WIDTH];

/*
 * Renders the wpm counter.
 */
static void render_wpm(uint8_t wpm) {
    oled_set_cursor(0, 0);
    oled_write("WPM", false);
    oled_set_cursor(0, 1);
    oled_write(get_u8_str(wpm, '0'), false);
}

/*
 * Renders the keyboard matrix.
 */
static void render_matrix(keyrecord_t *record) {
    uint8_t x      = _MATRIX_X;
    uint8_t y      = _MATRIX_Y;
    uint8_t width  = _MATRIX_WIDTH;
    uint8_t height = _MATRIX_HEIGHT;
#ifdef SPLIT_KEYBOARD
    uint8_t rows = _NML_MATRIX_ROWS;
    uint8_t cols = _NML_MATRIX_COLS;
#endif

    // On initial render draw the matrix outline
    if (!is_initialized) {
        for (uint8_t i = 1; i <= width - 2; i++) {
            oled_write_pixel(x + i, y, true);
            oled_write_pixel(x + i, y + height - 1, true);
        }
        for (uint8_t j = 1; j <= height - 2; j++) {
            oled_write_pixel(x, y + j, true);
            oled_write_pixel(x + width - 1, y + j, true);
        }
        return;
    }

    // Determine position based on matrix rotation
    // For split keyboards the keys on the right half get appended as additional rows and
    // have their columns reset at 0
#ifdef SPLIT_KEYBOARD
    uint8_t row = (record->event.key.row % rows);
    uint8_t col = record->event.key.col;
    if (record->event.key.row >= rows) {
        col += (cols / 2);
    }
#else
    uint8_t row = record->event.key.row;
    uint8_t col = record->event.key.col;
#endif

#ifdef TYPEHUD_MATRIX_ROW_SHIFT
    row += TYPEHUD_MATRIX_ROW_SHIFT;
#endif
#ifdef TYPEHUD_MATRIX_COL_SHIFT
    col += TYPEHUD_MATRIX_COL_SHIFT;
#endif

    // Scale position to key size
    uint8_t size = _MATRIX_SIZE;
    row *= size;
    col *= size;

    // Render key in matrix
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
#if defined(TYPEHUD_MATRIX_ROTATE_90)
            uint8_t key_x = x + width - 1 - size - row;
            uint8_t key_y = y + 1 + col;
#elif defined(TYPEHUD_MATRIX_ROTATE_180)
            uint8_t key_x = x + width - 1 - size - col;
            uint8_t key_y = y + height - 1 - size - row;
#elif defined(TYPEHUD_MATRIX_ROTATE_270)
            uint8_t key_x = x + 1 + row;
            uint8_t key_y = y + height - 1 - size - col;
#else
            uint8_t key_x = x + 1 + col;
            uint8_t key_y = y + 1 + row;
#endif
            oled_write_pixel(key_x + i, key_y + j, record->event.pressed);
        }
    }
}

/*
 * Renders the graph.
 */
static void render_graph(uint8_t wpm) {
    uint8_t x      = _GRAPH_X;
    uint8_t y      = _GRAPH_Y + _GRAPH_HEIGHT;
    uint8_t width  = _GRAPH_WIDTH;
    uint8_t height = _GRAPH_HEIGHT;

    // Handle intial graph render
    if (!is_initialized) {
        for (uint8_t i = 0; i < width; i++) {
            oled_write_pixel(x + i, y, true);
        }
        return;
    }

    uint8_t i = 0;

    // Shift all graph points except last to the left and re-render
    for (; i < width - 1; i++) {
        int8_t point_delta = point_arr[i + 1] - point_arr[i];

#ifdef TYPEHUD_FILLGRAPH
        if (point_delta < 0) {
#else
        if (point_delta != 0) {
#endif
            oled_write_pixel(x + i, y - point_arr[i], false);
        }

        wpm_arr[i]   = wpm_arr[i + 1];
        point_arr[i] = point_arr[i + 1];

        if (point_delta != 0) {
            oled_write_pixel(x + i, y - point_arr[i], true);
        }
    }

    // Clear last graph point
    if (wpm > wpm_arr[i] && point_arr[i] + 1 <= height) {
#ifndef TYPEHUD_FILLGRAPH
        oled_write_pixel(x + i, y - point_arr[i], false);
#endif
        point_arr[i] = point_arr[i] + 1;
    } else if ((wpm < wpm_arr[i] && point_arr[i] - 1 >= 0) || (wpm <= 0 && point_arr[i] > 0)) {
        oled_write_pixel(x + i, y - point_arr[i], false);
        point_arr[i] = point_arr[i] - 1;
    }

    // Render last graph point
    wpm_arr[i] = wpm;

    if (point_arr[i] != point_arr[i - 1]) {
        oled_write_pixel(x + i, y - point_arr[i], true);
    }
}

/*
 * Renders the caret.
 */
static void render_caret(void) {
    uint8_t x        = _GRAPH_X + _GRAPH_WIDTH + _GRAPH_RPAD + _CARET_WIDTH;
    uint8_t y        = 0;
    uint8_t width    = _CARET_WIDTH;
    uint8_t height   = _CARET_HEIGHT;
    uint8_t g_width  = _GRAPH_WIDTH;
    uint8_t g_height = _GRAPH_HEIGHT;

    // Handle initial caret render
    if (!is_initialized) {
        y = g_height - point_arr[g_width - 1];

        for (uint8_t i = 0; i < width; i++) {
            for (uint8_t j = i; j < height - i; j++) {
                oled_write_pixel(x - i, y - j, true);
            }
        }
        return;
    }

    // Handle caret updates and re-render
    int8_t point_delta = point_arr[g_width - 1] - point_arr[g_width - 2];
    if (point_delta > 0) {
        y = g_height - point_arr[g_width - 2];
        if (y - height + 1 > 0) {
            for (uint8_t i = 0; i < width; i++) {
                oled_write_pixel(x - i, y - i, false);
                oled_write_pixel(x - i, y - height + i, true);
            }
        }
    } else if (point_delta < 0) {
        y = g_height - point_arr[g_width - 1];
        if (y - height + 1 > 0) {
            for (uint8_t i = 0; i < width; i++) {
                oled_write_pixel(x - i, y - height + i, false);
                oled_write_pixel(x - i, y - i, true);
            }
        }
    }
}

/*
 * Renders the axis.
 */
static void render_axis(void) {
    uint8_t x             = _AXIS_X;
    uint8_t y             = _AXIS_HEIGHT;
    uint8_t width         = _AXIS_WIDTH;
    uint8_t height        = _AXIS_HEIGHT;
    uint8_t tick_width    = _AXIS_TICK_WIDTH;
    uint8_t subtick_width = _AXIS_SUBTICK_WIDTH;
    uint8_t interval      = _AXIS_INTERVAL;
    uint8_t tick_interval = _AXIS_TICK_INTERVAL;

    for (uint8_t j = 0; j <= height; j += interval) {
        uint8_t curr_tick_width = 0;

        // Determine tick width and draw extra point if at interval
        if (j % tick_interval == 0) {
            curr_tick_width = tick_width;
            oled_write_pixel(x, y - j, true);
        } else {
            curr_tick_width = subtick_width;
        }

        // Draw tick
        for (uint8_t i = 0; i < curr_tick_width; i++) {
            oled_write_pixel(x + width - i, y - j, true);
        }
    }
}

/*
 * Renders the input bar.
 */
static void render_bar(void) {
    uint8_t x      = _BAR_X;
    uint8_t width  = _BAR_WIDTH;
    uint8_t height = _BAR_HEIGHT;

    // Increment bar height
    bar_height = (bar_height + 1) % height;

    // When bar resets back to 0, clear bar pixels
    if (bar_height % height == 0) {
        for (uint8_t i = 0; i < width; i++) {
            for (uint8_t j = 0; j < height; j++) {
                oled_write_pixel(x + i, j, false);
            }
        }
    }

    // Draw new bar pixels
    for (uint8_t i = 0; i < width; i++) {
        oled_write_pixel(x + i, height - bar_height, true);
    }
}

/*
 * Renders the initial frame for all components.
 */
static void render_init(void) {
    render_graph(0);
    render_caret();
    render_matrix(NULL);
    render_axis();
}

/*
 * Initializes and resets the typehud.
 */
void typehud_init(void) {
    // Reset variables
    is_initialized = false;
    timer          = 0;
    bar_height     = -1;

    for (uint8_t i = 0; i < _GRAPH_WIDTH; i++) {
        wpm_arr[i]   = 0;
        point_arr[i] = 0;
    }

    // Draw the initial graph
    for (uint8_t i = 0; i < _GRAPH_WIDTH; i++) {
        oled_write_pixel(_GRAPH_X + i, _GRAPH_HEIGHT, true);
    }
}

/*
 * Renders the typehud.
 */
void typehud_render(void) {
    uint8_t wpm = get_current_wpm();

    // Run initial rendering once
    if (!is_initialized) {
        render_init();
        is_initialized = true;
    }

    // Render wpm
    render_wpm(wpm);

    // Render next graph and caret frame when timer reaches refresh rate
    if (timer_elapsed(timer) > _GRAPH_REFRESH) {
        render_graph(wpm);
        render_caret();
        timer = timer_read();
    }
}

/*
 * Handles keypresses for the typehud.
 */
void typehud_process_record(keyrecord_t *record) {
    // For split keyboards, only draw on correct side
#ifdef SPLIT_KEYBOARD
#    ifdef TYPEHUD_MASTER
    if (!is_keyboard_master()) {
#    else
    if (is_keyboard_master()) {
#    endif
        return;
    }
#endif
    // Render/update matrix
    render_matrix(record);

    // Render/update input bar on keypress
    if (record->event.pressed) {
        render_bar();
    }
}

==================================================
File: keymap.c
==================================================

/* Copyright 2022 mohoyt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include QMK_KEYBOARD_H
#include <stdio.h>

static long int oled_timeout = 600000; // 10 minutes
bool gui_on = true;
char wpm_str[10];
uint32_t anim_timer = 0;
uint32_t anim_sleep = 0;
uint8_t current_idle_frame = 0;
uint8_t current_tap_frame = 0;

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
  [0] = LAYOUT_base(
    KC_ESC,  KC_1,    KC_2,    KC_3,    KC_4,    KC_5,    KC_6,    KC_7,    KC_8,    KC_9,    KC_0,    KC_MINS, KC_EQL,  KC_BSPC, KC_HOME,
    KC_TAB,  KC_Q,    KC_W,    KC_E,    KC_R,    KC_T,    KC_Y,    KC_U,    KC_I,    KC_O,    KC_P,    KC_LBRC, KC_RBRC, KC_BSLS, KC_END, KC_MPLY,
    KC_CAPS, KC_A,    KC_S,    KC_D,    KC_F,    KC_G,    KC_H,    KC_J,    KC_K,    KC_L,    KC_SCLN, KC_QUOT,          KC_ENT,  KC_PGUP,KC_MUTE,
    LSFT_T(KC_GRV),   KC_Z,    KC_X,    KC_C,    KC_V,    KC_B,    KC_N,    KC_M,    KC_COMM, KC_DOT,  KC_SLSH, KC_RSFT, KC_UP,   KC_PGDN,
    KC_LCTL, KC_LGUI, KC_LALT,                            KC_SPC,                             KC_RALT,   MO(1), KC_LEFT, KC_DOWN, KC_RGHT ),

  [1] = LAYOUT_base(
  	KC_TRNS, KC_F1,   KC_F2,   KC_F3,   KC_F4,   KC_F5,   KC_F6,   KC_F7,   KC_F8,   KC_F9,   KC_F10,  KC_F11, KC_F12,  KC_DEL, KC_HOME,
    KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
    KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,          KC_TRNS, KC_TRNS, KC_MUTE,
    KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_UP,   KC_TRNS,
    KC_LCTL, KC_LGUI, KC_LALT,                            KC_SPC,                             KC_RALT, KC_RCTL, KC_LEFT, KC_DOWN, KC_RGHT )
};

//Encoder map
#if defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][2][2] = {
    [0] =   { ENCODER_CCW_CW(KC_MPRV, KC_MNXT), ENCODER_CCW_CW(KC_VOLD, KC_VOLU)  },
    [1] =  { ENCODER_CCW_CW(KC_MPRV, KC_MNXT), ENCODER_CCW_CW(KC_VOLD, KC_VOLU)  }
};
#endif

//OLED stuff here
#ifdef OLED_ENABLE
oled_rotation_t oled_init_user(oled_rotation_t rotation) {
   return OLED_ROTATION_180;  // flips the display 180 degrees
}

static void render_anim(void) {

    // Idle animation
    static const char PROGMEM idle[IDLE_FRAMES][ANIM_SIZE] = {

        {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,16,8,8,4,4,4,8,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,100,130,2,2,2,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,192,193,193,194,4,8,16,32,64,128,0,0,0,128,128,128,128,64,64,
            64,64,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,56,4,3,0,0,0,0,0,0,0,12,12,12,13,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,7,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        },

        {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,16,8,8,4,4,4,8,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,100,130,2,2,2,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,192,193,193,194,4,8,16,32,64,128,0,0,0,128,128,128,128,64,64,
            64,64,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,56,4,3,0,0,0,0,0,0,0,12,12,12,13,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,
            7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        },

        {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,64,64,64,64,32,32,32,32,16,8,4,2,2,4,24,96,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,194,1,1,2,2,4,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,96,0,129,130,130,132,8,16,32,64,128,0,0,0,0,128,128,128,128,64,64,64,64,32,
            32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,25,6,0,0,0,0,0,0,0,24,24,24,27,3,0,64,160,34,36,20,18,18,18,11,8,8,8,8,5,5,9,9,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,7,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        },

        {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,4,2,1,1,2,12,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,225,0,0,1,1,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,192,193,193,194,4,8,16,32,64,128,0,0,0,128,128,128,128,64,64,
            64,64,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,0,0,0,0,0,12,12,12,13,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,
            7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        },

        {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,8,4,2,2,2,4,56,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,226,1,1,2,2,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,192,193,193,194,4,8,16,32,64,128,0,0,0,128,128,128,128,64,64,64,64,
            32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,0,0,0,0,0,12,12,12,13,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,7,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        }

    };

    // Prep animation
    static const char PROGMEM prep[][ANIM_SIZE] = {

        {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,4,2,1,1,2,12,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,225,0,0,1,1,2,2,129,128,128,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,0,1,225,26,6,9,49,53,1,138,124,0,0,128,128,128,128,64,64,
            64,64,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,24,6,5,152,153,132,195,124,65,65,64,64,32,33,34,18,17,17,17,9,8,8,8,8,4,4,4,4,4,4,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        }

    };

    // Typing animation
    static const char PROGMEM tap[TAP_FRAMES][ANIM_SIZE] = {

        {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,4,2,1,1,2,12,48,64,128,0,0,0,0,0,0,0,248,248,248,248,0,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,225,0,0,1,1,2,2,129,128,128,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,0,1,1,2,4,8,16,32,67,135,7,1,0,184,188,190,159,
            95,95,79,76,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,24,6,5,152,153,132,67,124,65,65,64,64,32,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,61,124,252,252,252,252,252,60,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,
            1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        },

        {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,4,2,1,1,2,12,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,225,0,0,1,1,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,0,1,225,26,6,9,49,53,1,138,124,0,0,128,128,128,128,64,64,64,64,32,
            32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,0,0,0,0,0,0,0,0,1,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,4,4,4,4,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,122,122,121,121,121,121,57,49,2,2,4,4,8,8,8,136,136,135,128,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        }

    };

    void animation_phase(void) {
        if (get_current_wpm() <=IDLE_SPEED) {
            current_idle_frame = (current_idle_frame + 1) % IDLE_FRAMES;
            oled_write_raw_P(idle[abs((IDLE_FRAMES-1)-current_idle_frame)], ANIM_SIZE);
        }

        if (get_current_wpm() >IDLE_SPEED && get_current_wpm() <TAP_SPEED) {
            oled_write_raw_P(prep[0], ANIM_SIZE);
        }

        if (get_current_wpm() >=TAP_SPEED) {
            current_tap_frame = (current_tap_frame + 1) % TAP_FRAMES;
            oled_write_raw_P(tap[abs((TAP_FRAMES-1)-current_tap_frame)], ANIM_SIZE);
        }
    }

    if (get_current_wpm() != 000) {
        oled_on();

        if (timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
            anim_timer = timer_read32();
            animation_phase();
        }

        anim_sleep = timer_read32();
    } else {
        if (timer_elapsed32(anim_sleep) > oled_timeout) {
            oled_off();
        } else {
            if (timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
                anim_timer = timer_read32();
                animation_phase();
            }
        }
    }
}

bool oled_task_user(void) {
        render_anim();
        oled_set_cursor(0,4);
        sprintf(wpm_str, "WPM: %03d", get_current_wpm());
        oled_write(wpm_str, false);

    return false;
}

#endif


==================================================
File: config.h
==================================================


#pragma once

#define VIAL_KEYBOARD_UID {0x8C, 0x59, 0x2E, 0xF7, 0xBA, 0x40, 0xCC, 0xCA}

//#define ENCODERS_PAD_A { C6, F5 }
//#define ENCODERS_PAD_B { D4, F4 }
#undef ENCODERS_PAD_A
#undef ENCODERS_PAD_B
#define ENCODERS_PAD_A { D4, F4 }
#define ENCODERS_PAD_B { C6, F5 }
#define VIAL_COMBO_ENTRIES 2
#define VIAL_TAP_DANCE_ENTRIES 4
#define VIAL_KEY_OVERRIDE_ENTRIES 2
#define DYNAMIC_KEYMAP_LAYER_COUNT 2
#define VIAL_UNLOCK_COMBO_ROWS { 0, 4 }
#define VIAL_UNLOCK_COMBO_COLS { 0, 14 }
#define VIAL_ENCODER_DEFAULT { KC_VOLD, KC_VOLU, KC_MPRV, KC_MNXT, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS }

// OLED setup for bongocat
#define IDLE_FRAMES 5
#define IDLE_SPEED 30
#define TAP_FRAMES 2
#define TAP_SPEED 40
#define ANIM_FRAME_DURATION 200
#define ANIM_SIZE 512
